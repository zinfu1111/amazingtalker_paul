//
//  Router.swift
//  DemoNetworkLayer
//
//  Created by Paul on 2022/3/15.
//

import Foundation


class Router<EndPoint: EndPointType>: NetworkRouter {
    var taskStatus: URLSessionTask.State? {
        return task?.state
    }
    
    var task: URLSessionTask?
    var group: DispatchQueue!
    var cerFileName: String!
    var timeoutInterval: Double = 10
    
    init() {
        if #available(iOS 10.0, *) {
            group = DispatchQueue(label: "CAllAPI", qos: .default, attributes: .concurrent, autoreleaseFrequency: .workItem, target: nil)
        } else {
            group = DispatchQueue(label: "CAllAPI")
        }
    }
    
    func request(_ route: EndPoint, SSLEnable: Bool = false, cerFileName: String = "", completion: @escaping NetworkRouterCompletion) {
        group.async {
            self.cerFileName = cerFileName
            let session = self.setupSSL(enable: SSLEnable)
            do {
                let request = try self.buildRequest(from: route)
                print("[Note]Request URL: \(String(describing: request.url))")
                self.task = session.dataTask(with: request, completionHandler: { (data, response, error) in
                    completion(data, response, error)
                })
            } catch {
                completion(nil, nil, error)
            }
            self.task?.resume()
        }
    }
    
    func cancel() {
        self.task?.cancel()
    }
    
    // MARK: private
    private func setupSSL(enable: Bool) -> URLSession {
        let session: URLSession!
        if !enable{
            session = URLSession(configuration: .default)
            return session
        }else{
            // SSL
            let delegate = SessionDelegate(cerResource: cerFileName)
            let configuration = URLSessionConfiguration.default
            configuration.networkServiceType = .responsiveData
            session = URLSession(configuration: configuration, delegate: delegate, delegateQueue: OperationQueue.current)
            return session
        }
    }
}
// MARK: Build Request (Private)
extension Router{
    // EndPointType building to request
    private func buildRequest(from route: EndPoint) throws -> URLRequest{
        
        // Create a URLRequest variable, generated by route.baseURL followed by a specific route.path
        // .reloadIgnoringLocalAndRemoteCacheData: cache isn't save.
        var request = URLRequest(
            url: route.baseURL.appendingPathComponent(route.path),
            cachePolicy: .reloadIgnoringLocalAndRemoteCacheData,
            timeoutInterval: timeoutInterval)
        
        request.allHTTPHeaderFields = route.headers
        
        // set url method
        request.httpMethod = route.httpMethod.rawValue
        
        // set url task
        do {
            switch route.task {
            case .requestParameters(let bodyParameters, let urlParameters):
                try configureURL(&request, parameters: urlParameters)
                try configureBody(&request, parameters: bodyParameters)
                break
            case .requestCodable(let bodyParameters, let urlParameters):
                try configureURL(&request, parameters: urlParameters)
                try configureBody(&request, Codable: bodyParameters)
                break
            case .requestIMGParameters(let bodyParameters, let urlParameters, let dataParameters):
//                addAdditionalHeaders(additionHeaders, request: &request)
                try configureURL(&request, parameters: urlParameters)
                try configureBody(&request, parameters: bodyParameters, dataParameters: dataParameters)

            case .requestWithParameters(bodyParameters: let bodyParameters, urlParameters: let urlParameters):
                // 配置參數
                try configureParameters(bodyParameters: bodyParameters,
                                        urlParameters: urlParameters,
                                        request: &request)
            case .requestWithParametersAndHeaders(bodyParameters: let bodyParameters, urlParameters: let urlParameters, additionHeaders: let additionHeaders):
                // 新增額外的 Headers ，配置參數
                self.addAdditionalHeaders(additionHeaders, request: &request)
                try configureParameters(bodyParameters: bodyParameters,
                                        urlParameters: urlParameters,
                                        request: &request)
            }
            return request
        } catch {
            throw error
        }
    }
    
    private func configureURL(_ request: inout URLRequest, parameters: URLParameters?) throws{
        do {
            if let bodyParameters = parameters{
                try URLParameterEncoder.encode(urlRequest: &request, with: bodyParameters)
            }
        } catch {
            throw error
        }
    }
    
    /// Use `JSONParameterEncoder` _JSON
    ///
    /// - Parameters:
    ///   - bodyParameters: JSON format
    ///   - request: URLRequest
    /// - Throws: NetworkError
    private func configureBody(_ request: inout URLRequest, parameters: Parameters?) throws{
        do {
            if let bodyParameters = parameters{
                try JSONParameterEncoder.encode(urlRequest: &request, with: bodyParameters)
            }
        } catch {
            throw error
        }
    }
    
    /// Use `JSONParameterEncoder` _JSON
    ///
    /// - Parameters:
    ///   - bodyParameters: Encodable JSON
    ///   - urlParameters: URL format
    ///   - request: URLRequest
    /// - Throws: NetworkError
    fileprivate func configureBody(_ request: inout URLRequest, Codable Parameters: EncodableParameters?) throws{
        do {
            if let bodyParameters = Parameters{
                try JSONParameterEncoder.encode(urlRequest: &request, with: bodyParameters)
            }
        } catch {
            throw error
        }
    }
    
    /// Use `JSONParameterEncoder` _format
    ///
    /// - Parameters:
    ///   - bodyParameters: JSON format
    ///   - request: URLRequest
    /// - Throws: NetworkError
    fileprivate func configureBody(_ request: inout URLRequest, parameters: Parameters?, dataParameters: Parameters?) throws{
        do {
            if let parameters = parameters, let dataParameters = dataParameters{
                try FormatParameterEncoder.encode(urlRequest: &request, with: parameters, dataParmaters: dataParameters)
            }
        } catch {
            throw error
        }
    }

    
    fileprivate func configureParameters(bodyParameters: Parameters?,
                                         urlParameters: Parameters?,
                                         request: inout URLRequest) throws {
        do {
            // bodyParameters 為 JSON 格式，使用 JSONParameterEncoder 來編碼
            if let bodyParameters = bodyParameters {
                try JSONParameterEncoder.encode(urlRequest: &request, with: bodyParameters)
            }
          // urlParameters 為 URL 編碼，使用 JSONParameterEncoder 來編碼
            if let urlParameters = urlParameters {
                try URLParameterEncoder.encode(urlRequest: &request, with: urlParameters)
            }
        } catch {
            // 獲取 Encoder 可能拋出的錯誤訊息
            throw error
        }

    }
    
    fileprivate func addAdditionalHeaders(_ additionalHeader: HTTPHeaders?,
                                          request: inout URLRequest) {
        guard let headers = additionalHeader else { return }
        for (key, value) in headers {
            request.setValue(value, forHTTPHeaderField: key)
        }
    }
}
